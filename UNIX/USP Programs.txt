Program to check and display _POSIX_VERSION constant of the system on which it is run.

#define _POSIX_SOURCE
#define _POSIX_C_SOURCE 199309L
#include<iostream.h>
#include<unistd.h>
int main(){
	#ifdef _POSIX_VERSION
		cout<<“System conforms to POSIX”<<“_POSIX_VERSION<<endl;
	#else
		cout<<“_POSIX_VERSION undefined\n”;
	#endif
	return 0;
}

###############################################################################################################

Program to print POSIX defined configuration options supported on any given system. OR
Write a C/C++ program for POSIX feature test macros. 

#define _POSIX_SOURCE
#define _POSIX_C_SOURCE 199309L
#include <iostream.h>
#include <unistd.h>

int main() {
  #ifdef _POSIX_JOB_CONTROL
  cout << “system supports job control”;
  #else
  cout << “system does not support job control\ n”;
  #endif
  #ifdef _POSIX_SAVED_IDS
  cout << “system supports saved set - UID and set - GID”;
  #else
  cout << “system does not support set - uid and gid\ n”;
  #endif
  #ifdef _POSIX_CHOWN_RESTRICTED
  cout << “chown_restricted option is: ”
    <<
    _POSIX_CHOWN_RESTRICTED << endl;
  #else
  cout << ”system does not support” <<
    ”chown_restricted option\ n”;
  #endif
  #ifdef _POSIX_NO_TRUNC
  cout << ”pathname trunc option is: ”
    <<
    _POSIX_NO_TRUNC << endl;
  #else
  cout << ”system does not support system - wide pathname” <<
    ”trunc option\ n”;
  #endif
  #ifdef _POSIX_VDISABLE
  cout << “disable char.for terminal files is: ”
    <<
    _POSIX_VDISABLE << endl;
  #else
  cout << “system does not support _POSIX_VDISABLE\ n”;
  #endif
  return 0;
}

###############################################################################################################

POSIX compliant program to check the following limits: 
(i) No. of clock ticks 
(ii) Max. no. of child processes 
(iii) Max. path length 
(iv) Max. no. of characters in a file name 
(v) Max. no. of open files/ process

#define _POSIX_SOURCE
#define _POSIX_C_SOURCE 199309 L#include<stdio.h>

#include<unistd.h>

int main() {
  int res;
  if ((res = sysconf(_SC_OPEN_MAX)) == -1)
    perror("sysconf");
  else
    printf("OPEN_MAX:%d\n", res);
  if ((res = pathconf("/", _PC_NAME_MAX)) == -1)
    perror("pathconf");
  else
    printf("max_path name:%d\n", res);
  if ((res = sysconf(_SC_CLK_TCK)) == -1)
    perror("sysconf");
  else
    printf("clock ticks:%d\n", res);
  if ((res = sysconf(_SC_CHILD_MAX)) == -1)
    perror("sysconf");
  else
    printf("max_childs:%d\n", (res));
  if ((res = pathconf("/", _PC_PATH_MAX)) == -1)
    perror("pathconf");
  else
    printf("max path name length:%d\n", res);
  return 0;
}
###############################################################################################################

Consider the last 100 bytes as a region. Write a C/C++ program to check whether the region is locked or not.
If the region is locked, print pid of the process which has locked. Ifthe region is not locked, lock the
region with an exclusive lock, read the last 50 bytes and unlock the region.

#include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <errno.h>
 int main(int argc,char *argv[])
 {
        int fd;
        char buffer[255];
        struct flock fvar;
        if(argc==1)
        {
                printf("usage: %s filename\n",argv[0]);
                return -1;
        }
        if((fd=open(argv[1],O_RDWR))==-1)
        {
                perror("open");
                exit(1);
        }
        fvar.l_type=F_WRLCK;
        fvar.l_whence=SEEK_END;
        fvar.l_start=SEEK_END-100;
        fvar.l_len=100;
        printf("press enter to set lock\n");
        getchar();
        printf("trying to get lock..\n");
        if((fcntl(fd,F_SETLK,&fvar))==-1)
        {     fcntl(fd,F_GETLK,&fvar);
              printf("\nFile already locked by process (pid):    \t%d\n",fvar.l_pid);        
              return -1;        
        }
        printf("locked\n");
        if((lseek(fd,SEEK_END-50,SEEK_END))==-1)
        {
                perror("lseek");
                exit(1);
        }
        if((read(fd,buffer,100))==-1)
        {
                perror("read");
                exit(1);
        }
        printf("data read from file..\n");
        puts(buffer);
        printf("press enter to release lock\n");
        getchar();
        fvar.l_type = F_UNLCK;
        fvar.l_whence = SEEK_SET;
        fvar.l_start = 0;
        fvar.l_len = 0;
        if((fcntl(fd,F_UNLCK,&fvar))==-1)
        {
                perror("fcntl");
                exit(0);
        }
        printf("Unlocked\n");
        close(fd);
        return 0;
 }

###############################################################################################################

C Program to print environment variables.

#include <stdio.h>
 
void main(int argc, char *argv[], char * envp[])
{
    int i;
 
    for (i = 0; envp[i] != NULL; i++)
    {    
        printf("\n%s", envp[i]);
    }
}

###############################################################################################################

PROGRAM: shows the code to create a pipe between a parent and its child and to send data down the pipe.

#include "apue.h"

int
main(void) {
  int n;
  int fd[2];
  pid_t pid;
  char line[MAXLINE];
  if (pipe(fd) < 0)
    err_sys("pipe error");
  if ((pid = fork()) < 0) {
    err_sys("fork error");
  } else if (pid > 0) {
    /* parent */
    close(fd[0]);
    write(fd[1], "hello world\n", 12);
  } else {
    /* child */
    close(fd[1]);
    n = read(fd[0], line, MAXLINE);
    write(STDOUT_FILENO, line, n);
  }
  exit(0);
}

###############################################################################################################

setjump and longjump in C

// A simple C program to demonstrate working of setjmp() and longjmp()
#include<stdio.h>
#include<setjmp.h>
jmp_buf buf;
void func()
{
	printf("Welcome to GeeksforGeeks\n");

	// Jump to the point setup by setjmp
	longjmp(buf, 1);

	printf("Geek2\n");
}

int main()
{
	// Setup jump position using buf and return 0
	if (setjmp(buf))
		printf("Geek3\n");
	else
	{
		printf("Geek4\n");
		func();
	}
	return 0;
}

###############################################################################################################

Witli a siuple C prograin to illustrule theconcept of a co-process.

Ex: : Simple filter to add two numbers

#include "apue.h"

int main(void) {
  int n, int1, int2;
  char line[MAXLINE];
  while ((n = read(STDIN_FILENO, line, MAXLINE)) > 0) {
    line[n] = 0; /* null terminate */
    if (sscanf(line, "%d%d", & int1, & int2) == 2) {
      sprintf(line, "%d\n", int1 + int2);
      n = strlen(line);
      if (write(STDOUT_FILENO, line, n) != n)
        err_sys("write error");
    } else {
      if (write(STDOUT_FILENO, "invalid args\n", 13) != 13)
        err_sys("write error");
    }
  }
  exit(0);
}

###############################################################################################################

Write a program to setup signal handler for the SIGINT signal using sigaction API.

#include<iostream.h>
#include<stdio.h>
#include<unistd.h>
#include<signal.h>

void callme(int sig_num) {
  cout << ”
    catch signal: ” << sig_num << endl;
}
int main(int argc, char * argv[]) {
  sigset_t sigmask;
  struct sigaction action, old_action;
  sigemptyset( & sigmask);
  if (sigaddset( & sigmask, SIGTERM) == -1 || sigprocmask(SIG_SETMASK, & sigmask, 0) == -1)
    perror(“set signal mask”);
  sigemptyset( & action.sa_mask);
  sigaddset( & action.sa_mask, SIGSEGV);
  action.sa_handler = callme;
  action.sa_flags = 0;
  if (sigaction(SIGINT, & action, & old_action) == -1)
    perror(“sigaction”);
  pause();
  cout << argv[0] << ”exists\ n”;
  return 0;
}